function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import omit from 'lodash/omit';
import assign from 'lodash/assign';
import isFunction from 'lodash/isFunction';
import { isPromise } from '../_util/is';
import actionLogger from '../_util/action-logger';
import PubSub from '../_util/pubsub';
export var STOP = '@@sula_action_stop';
export var ERROR = '@@sula_action_error';
export var FINISH = '@@sula_action_finish';
export var rejectSTOP = function rejectSTOP() {
  return Promise.reject(STOP);
};

var Rope = function Rope(proto) {
  var _this = this;

  _classCallCheck(this, Rope);

  this.proto = void 0;
  this.stack = [];

  this.proxy = function () {
    // ropeContainer 触发，已经 getCtx 过
    return function (ctx) {
      var results = {};
      var finalCtx = ctx;
      var stackIndex = 0;

      var next = function next(result) {
        var prevStackItem = _this.stack[stackIndex];

        if (prevStackItem.resultPropName) {
          results[prevStackItem.resultPropName] = result;
        }

        stackIndex += 1;
        var curStackItem = _this.stack[stackIndex];

        if (!curStackItem) {
          return;
        }

        assign(finalCtx, {
          results: results,
          result: result
        });

        if (curStackItem.trigger) {
          curStackItem.trigger(finalCtx, next);
        }
      };

      var curStackItem = _this.stack[stackIndex];

      if (curStackItem && curStackItem.trigger) {
        curStackItem.trigger(finalCtx, next);
      }
    };
  };

  this.use = function (action) {
    var actionConfig;
    var stackItem = {};
    stackItem.before = action.before;
    stackItem.error = action.error;
    stackItem.final = action.final;
    stackItem.resultPropName = action.resultPropName;
    stackItem.actionType = isFunction(action.type) ? action.type.name : action.type;
    actionConfig = omit(action, ['before', 'error', 'final', 'resultPropName']);

    stackItem.trigger = function (ctx, next) {
      actionLogger('action', stackItem.actionType);

      if (!stackItem.before) {
        stackItem.handle(ctx, next);
      } else {
        _this.handleBeforeResult(stackItem.before, ctx, function (beforeExecuteResult) {
          if (beforeExecuteResult.type === FINISH) {
            actionLogger('beforePass');
            stackItem.handle(ctx, next);
          } else {
            PubSub.pub(STOP);
            actionLogger('beforeStop');
          }
        });
      }
    };
    /**
     * ctx会在中间件中添加新属性
     */


    stackItem.handle = function (ctx, next) {
      _this.handleResult(ctx, actionConfig, function (executeResult) {
        if (executeResult.type === FINISH) {
          actionLogger('actionSuccess', executeResult.payload);
          next(executeResult.payload);
        } else if (executeResult.type === STOP) {
          PubSub.pub(STOP);
          actionLogger('actionError', executeResult.payload);

          if (stackItem.error) {
            stackItem.error(ctx);
          }
        }

        if (stackItem.final) {
          stackItem.final(ctx);
        }
      });
    };

    _this.stack.push(stackItem);

    return _this;
  };

  this.handleResult = function (ctx, actionConfig, dispatch) {
    // 不直接使用triggerActionPlugin，解耦
    var executeResult = _this.proto.trigger(ctx, actionConfig);

    if (isPromise(executeResult)) {
      executeResult.then(function (result) {
        dispatch({
          type: FINISH,
          payload: result
        });
      }, function (error) {
        dispatch({
          type: STOP,
          payload: error
        });
      });
    } else {
      dispatch({
        type: FINISH,
        payload: executeResult
      });
    }
  };

  this.handleBeforeResult = function (beforeHook, ctx, dispatch) {
    var beforeResult = beforeHook(ctx);

    if (isPromise(beforeResult)) {
      beforeResult.then(function (result) {
        dispatch({
          type: FINISH,
          payload: result
        });
      }, function () {
        dispatch({
          type: STOP
        });
      });
    } else {
      if (beforeResult === false) {
        dispatch({
          type: STOP
        });
      } else {
        dispatch({
          type: FINISH
        });
      }
    }
  };

  this.proto = proto;
};

export { Rope as default };