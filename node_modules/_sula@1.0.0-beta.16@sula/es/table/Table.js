import "antd/es/table/style";
import _Table from "antd/es/table";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React from 'react';
import omit from 'lodash/omit';
import isUndefined from 'lodash/isUndefined';
import assign from 'lodash/assign';
import useTableContext, { HOOK_MARK } from './useTableContext';
import { triggerRenderPlugin, triggerPlugin } from '../rope/triggerPlugin';
import TableAction from './TableAction';
import ModalForm from '../modalform';
import { SulaConfigContext } from '../config-provider/context';

var RefTable = function RefTable(props, ref) {
  var _useTableContext = useTableContext(),
      _useTableContext2 = _slicedToArray(_useTableContext, 1),
      context = _useTableContext2[0];

  var mountRef = React.useRef(false);
  var modalFormRef = React.useRef(null);
  var drawerFormRef = React.useRef(null);

  var _context$getInternalH = context.getInternalHooks(HOOK_MARK),
      getCtx = _context$getInternalH.getCtx,
      saveTableProps = _context$getInternalH.saveTableProps,
      setControls = _context$getInternalH.setControls,
      getControls = _context$getInternalH.getControls,
      getInternalControls = _context$getInternalH.getInternalControls,
      onRowSelectionChange = _context$getInternalH.onRowSelectionChange,
      onChange = _context$getInternalH.onChange,
      saveModalFormRef = _context$getInternalH.saveModalFormRef,
      saveDrawerFormRef = _context$getInternalH.saveDrawerFormRef;

  React.useImperativeHandle(ref, context.getTable);
  saveTableProps(props);

  if (!mountRef.current) {
    mountRef.current = true;
    saveModalFormRef(modalFormRef);
    saveDrawerFormRef(drawerFormRef);
    var tableControls = parseTableControls(props);
    setControls(tableControls);
  }

  React.useEffect(function () {
    if (props.remoteDataSource && props.remoteDataSource.init !== false) {
      var table = context.getTable(); // 初始化数据源不能清空选中项

      table.refreshTable(null, null, null, true);
    }
  }, []);
  var tableProps = omit(props, ['remoteDataSource', 'initialDataSource', 'initialPaging', 'initialSelectedRowKeys', 'ctxGetter']);
  var configContext = React.useContext(SulaConfigContext); // =============== Table 级别 ===============

  var controls = getControls();
  tableProps.dataSource = controls.dataSource;
  tableProps.pagination = controls.pagination;
  var internalControls = getInternalControls();
  tableProps.loading = internalControls.loading;
  tableProps.onChange = onChange;

  if (tableProps.rowSelection) {
    tableProps.rowSelection = _objectSpread(_objectSpread({}, tableProps.rowSelection), {}, {
      onChange: onRowSelectionChange,
      selectedRowKeys: controls.selectedRowKeys
    });
  }

  if (props.actionsRender || props.leftActionsRender) {
    tableProps.title = function (currentPageData) {
      var ctx = getCtx({
        dataSource: currentPageData,
        history: configContext.history
      });
      return /*#__PURE__*/React.createElement(TableAction, {
        leftActionsRender: props.leftActionsRender,
        actionsRender: props.actionsRender,
        ctx: ctx
      });
    };
  } // =============== Column 级别 ===============


  tableProps.columns = tableProps.columns.map(function (column, index) {
    var key = column.key,
        sorter = column.sorter,
        filters = column.filters;
    var newColumn = {};

    if (!column.hasOwnProperty('dataIndex')) {
      newColumn.dataIndex = key;
    }

    var sorterColumnKey = controls && controls.sorter ? controls.sorter.columnKey : '';

    if (sorter && sorterColumnKey === key) {
      newColumn.sortOrder = controls.sorter.order;
    }

    if (filters && filters.length || column.filterRender) {
      newColumn.filteredValue = controls && controls.filters ? controls.filters[key] : undefined;
    }

    if (column.filterRender) {
      var filterOptions = triggerPlugin('filter', getCtx(), column.filterRender);
      assign(newColumn, filterOptions);
    }

    if (column.render) {
      newColumn.render = function (text, record, index) {
        var ctx = getCtx({
          text: text,
          record: record,
          index: index,
          history: configContext.history
        });
        return triggerRenderPlugin(ctx, column.render);
      };
    }

    return assign({}, column, newColumn);
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_Table, tableProps), /*#__PURE__*/React.createElement(ModalForm, {
    type: "drawer",
    ref: drawerFormRef
  }), /*#__PURE__*/React.createElement(ModalForm, {
    ref: modalFormRef
  }));
};

var defaultPagination = {
  current: 1,
  pageSize: 10
};

function parseTableControls(props) {
  var selectedRowKeys = props.initialSelectedRowKeys;
  var dataSource = props.initialDataSource || [];

  if (props.initialPaging === false) {
    return {
      selectedRowKeys: selectedRowKeys,
      dataSource: dataSource
    };
  }

  var pagination;

  if (isUndefined(props.initialPaging)) {
    pagination = assign({}, defaultPagination);
  } else if (props.initialPaging.pagination === false) {
    pagination = false;
  } else {
    pagination = assign({}, defaultPagination, props.initialPaging.pagination);
  }

  return assign({}, props.initialPaging, {
    pagination: pagination,
    selectedRowKeys: selectedRowKeys,
    dataSource: dataSource
  });
}

export default RefTable;